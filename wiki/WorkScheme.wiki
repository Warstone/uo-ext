Этот документ описывает основные моменты логики работы UOExt.

Вся работа делится на 3 части:
  # Заражение и загрузка UOExt.dll перед тем, как будет запущен основной ехе
  # Инициализация UOExt и запуск основного приложения
  # Работа прокси-сервера

Подробнее о каждой из частей:

==Заражение и загрузка==
Как написано в документе по [Installation установке], сначала надо "заразить" выполняемый файл UO. Это делается путем выполнения команды
{{{RunDll32.exe UOExt.dll,Infect32 <Executable>}}}

Где _Executable_ - название ехе.

Заражение выполняется путем внедрения новой секции кода и помещением туда исполняемого кода, который загружает UOExt.dll, а потом передает управление в точку входа приложения.

Это самый простой метод заражения, который уже довольно давно не используется при написании вирусов, но все-равно некоторые антивирусы могут начинать ругаться на неизвестный вирус.

==Инициализация==
Самая большая и сложная часть.

Инициализация начинается с того, что создаётся консоль и окно представления информации, потом происходит попытка подключиться к серверу для получения исходных настроек. Здесь необходимо остановиться подробнее.

Для начала, идет попытка вычислить IP и порт сервера. Алгоритм таков:
  # Посмотреть процесс-родитель. Если он Razor, то мы запущены из под Razor'а и тогда необходимо получить ip/порт из реестра.
  # Если родителя нету или он не является Razor'ом - попытаться прочесть Login.cfg

Потом происходит подключение к серверу и запрос настроек... Для того, чтобы не модифицировать протокол UO, первый пакет, который отправляется серверу - является пакетом 0xEF с пустыми полями. В обычном случае такого быть не может. По этому признаку сервер определяет что к нему подключается UOExt и возвращает специальный пакет настроек. В зависимости от этого UOExt или отключается и подключается к серверу обновлений или продолжает работать с текущим подключением считая что это сервер обновлений.

Дальше происходит процесс обновления UOExt.dll и UOExt.gui.dll. Так как на данном этапе UOExt совершенно не важно в какому клиенту от подцеплен (теоретически вы можете подцепить его к notepad.exe и он дойдет до этого места), то обновление самого клиента не производится. Так как UOExt ничего не знает о клиенте, то теоретически UOExt может работать с любым клиентом, даже Iris, хотя он и не тестировался с ним.

После процесса обновления идет инициализация плагинов. Более подробнее об этом можно прочитать в документе [PluginInit инициализация плагинов].

После этого производится перехват необходимых API'шек (на данный момент - connect) и управление передается основному приложению.

==Прокси-сервер==
Для начала я объясню зачем вообще нужен прокси-сервер...

Существует 2 подхода к реализации аналога UOExt:
  * Перехват send и recv и работа во время их вызова
  * Создание прокси-сервера

Перехват send и recv неудобен по нескольким причинам:
  * Вы не можете послать пакет "прямо сейчас", вам в любом случае надо ждать когда будет выполнен send или recv, а в некоторых игровых моментах это может занимать секунды.
  * Долгая обработка того или иного пакета будет видна клиенту как "тормоза" клиента.

Вариант с прокси-сервером лишен этих недостатков:
 * Пакет как клиенту так и серверу можно послать в любой момент.
 * Процесс работы клиента (2д) сейчас устроен так, что в случае неответа сервера, клиент может "бежать" еще 3-4 клетки, а это значит что у вас есть где-то секунда реального времени для обработки любого пакета (хотя и долгие вычисления желательно выводить в отдельные потоки). Фактически "тормоз" заменяется на "лаг" сети, но это менее неприятно.

===Теперь о том, как работает прокси-сервер===

Прокси-сервер выполняется в отдельном потоке и хоть и имеет общее адресное пространство с приложением, но не мешает ему. Таким образом, с одной стороны, вы можете модифицировать клиент, с другой - выполнять сложные расчеты по событию, не мешая ему. Это расширяет возможности модифицирования логики клиента до, практически, безграничных возможностей (во время подготовки первой версии и релиза промежуточных сборок были заявлены плагины, которые меняют логин окно клиента, заменяя его своим, пропускают процесс создания персонажа, реализуют свой звуковой движок и т.д. Вполне возможно, что на момент прочтения, эти плагины уже доступы для скачивания).

Итак, прокси-сервер слушает клиент и сервер и, как только данные пришли, пытается декодировать и расшифровать их. После этого он вызывает обработчики тех или иных пакетов и опять кодирует и шифрует пакеты, отправляя их дальше - серверу или клиенту.